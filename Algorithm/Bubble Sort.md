## 버블 정렬 (Bubble Sort)

<br>

인접한 두 원소를 검사하여 정렬하는 알고리즘이다.    
인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.    
```선택 정렬```과 기본 개념 유사하며 **오름차순**을 기준으로 정렬한다.    

<br>

## 알고리즘 특징 

- 거품 정렬은 점점 큰 값들을 뒤에서부터 앞으로 하나씩 쌓여 나가기 때문에 후반으로 갈수록 정렬 범위가 하나씩 줄어들게 된다. 
- 제일 작은 값을 찾아서 맨 앞에 위치시키는 ```선택 정렬```과 비교했을 때 정반대의 정렬 방향을 가진다.
- 다른 정렬 알고리즘에 비해서 자리 교대(swap)가 빈번하게 일어난는 경향을 가지고 있다. 예를 들어, ```선택 정렬```의 경우 각 패스에서 자리 교대가 딱 한 번만 일어난다. 
- 최적화 여지가 많은 알고리즘이다.


<br>

## 복잡도 분석 

- 거품 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 ```O(1)```의 공간 복잡도를 가진다. 
- 시간 복잡도는 우선 루프문을 통해 맨 뒤부터 맨 앞까지 모든 인덱스에 접근해야 하기 때문에 기본적으로 ```O(N)```의 시간을 소모하며, 하나의 루프에서는 인접한 값들의 대소 비교 및 자리 교대를 위해서 ```O(N)```의 시간이 필요하게 된다. 따라서 거품 정렬은 총 ```O(N²)```의 시간 복잡도를 가지는 정렬 알고리즘이다. 
- 하지만, 거품 정렬은 부분적으로 정렬되어 있는 배열에 대해서는 최적화를 통해서 성능을 대폭 개선할 수 있으며, 완전히 정렬되어 있는 배열이 들어올 겨우 ```O(N)```까지도 시간 복잡도를 향상시킬 수 있다. 

<br>

## 구현

선택 정렬과 마찬가지로 두 개의 반복문이 필요하다. 내부 반복문에서는 첫 번쨰 값부터 이전 순서에서 뒤로 보내놓은 값이 있는 위치 전까지 앞뒤 값을 계속해서 비교해 나가면서 앞의 값이 뒤의 값보다 클 경우 자리 교대(swap)를 한다. 외부 반복문에서는 뒤에서부터 앞으로 정렬 범위를 ```n-1```부터 ```1```까지 줄여나간다. 

<br>

<img src='https://user-images.githubusercontent.com/56749776/138304266-9efe4271-6c1f-4fbe-ab67-565244027ee2.png' width='100%'>

<br>

```py
def swap(x, i, j):
    x[i], x[j] = x[j], x[i]

def bubbleSort(x):
    for num in reversed(range(len(x))):
        for i in range(num):
            if x[i] > x[i+1]:
                swap(x, i, i+1)
```

<br>

## 최적화

이전 순서에서 자리 비교(swap)가 한 번도 일어나지 않았다면 정렬되지 않는 값이 하나도 없었다고 간주 할 수 있다. 따라서 이런 경우 이후 순서를 수행하지 않아도 된다. 

```py
def bubble_sort(arr):
    for i in range(len(arr)-1, 0, -1):
        swapped = False
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] =  arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
```

<br>

## 추가적인 최적화

이전 순서에서 앞뒤 자리 비교(swap)가 있었는지 여부를 확인하는 대신 마지막으로 앞 뒤 자리 비교가 있었던 index를 기억해두면 다음 순서에서는 그 자리 전까지만 정렬해도 된다. 따라서 한 칸씩 정렬 범위를 줄여나가는 대신 한 번에 여러 칸씩 정렬 범위를 줄여나갈 수 있다. 

```py
Start : [3, 2, 1, 4, 5]

1 : [2, 1, 3, 4, 5]  -> 마지막 swap 위치가 index : 1 
        ^        *
2 : [1, 2, 3, 4, 5]  -> 중간 순서 skip하고 바로 index 1로 
     ^     *  *  *      보낼 값 찾기
```

```py
def bubble_sort(arr):
    end = len(arr) - 1
    while end > 0:
        last_swap = 0
        for i in range(end):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                last_swap = i
        end = last_swap
```